<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Background demo</title>
  <script type="text/javascript" src="utils/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>
  <script type="text/javascript" src="utils/geocast-filereader.js"></script>

  <script id="view-lattice-shader-fs" type="x-shader/x-fragment">
    precision highp float;
    precision mediump float;

    varying vec4 pass_aPosition;
    varying vec4 pass_color;
    varying vec4 pass_discardFlag;

    void main(void) {
      if(pass_discardFlag.a < 0.999)
        discard;
      gl_FragColor = pass_color;
    }
  </script>
  <script id="view-lattice-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    precision mediump float;

    attribute vec3 aPosition;

    uniform mat4 uViewMVMatrix;
    uniform mat4 uViewProjMatrix;

    uniform mat4 uGeoCastMVMatrix;
    uniform mat4 uGeoCastProjMatrix;
    uniform mat4 uGeoCastMVMatrix_Inverse;
    uniform mat4 uGeoCastProjMatrix_Inverse;
    uniform vec2 uGeoCastClipRange;

    uniform sampler2D texDepthMapSampler;
    uniform sampler2D texColorMapSampler;

    varying vec4 pass_aPosition;
    varying vec4 pass_color;
    varying vec4 pass_discardFlag;

    void main(void) {
      pass_aPosition = vec4(aPosition.rgb, 1.0);

      vec4 depth = texture2D(texDepthMapSampler, aPosition.xy);
      pass_color = texture2D(texColorMapSampler, aPosition.xy);

      vec4 depth_camspace;  // purpose: "image" a pixel of depth Z (its view vector) into camera space
      depth_camspace = uGeoCastProjMatrix * vec4(0.0, 0.0, mix(-uGeoCastClipRange.x, -uGeoCastClipRange.y, depth.x), 1);

      float model_depth = depth_camspace.z / depth_camspace.w;
      // Discard background depths
      pass_discardFlag = vec4(1.0, 1.0, 1.0, (depth.x == 1.0) ? 0.0 : 1.0);

      // Lattice has coords [0;1], this doesn't use the full screen extents of the projector [-1;1]. Rescale
      vec2 latticePos = vec2(aPosition.x, aPosition.y);
      latticePos = latticePos * 2.0 - 1.0;

      vec4 worldpos = uGeoCastMVMatrix * uGeoCastProjMatrix_Inverse * vec4(latticePos.xy,  model_depth, 1);
      gl_Position = uViewProjMatrix * uViewMVMatrix * worldpos;
    }
  </script>

  <script id="camera-frustum-lines-shader-fs" type="x-shader/x-fragment">
    precision highp float;

    void main(void) {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
  </script>
  <script id="camera-frustum-lines-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec3 aPosition;

    uniform mat4 uViewMVMatrix;
    uniform mat4 uViewProjMatrix;

    uniform mat4 uGeoCastMVMatrix;
    uniform mat4 uGeoCastProjMatrix;
    uniform mat4 uGeoCastMVMatrix_Inverse;
    uniform mat4 uGeoCastProjMatrix_Inverse;
    uniform vec2 uGeoCastClipRange;

    void main(void) {

      gl_Position = uViewProjMatrix * uViewMVMatrix * (uGeoCastMVMatrix * uGeoCastProjMatrix_Inverse *  vec4(aPosition.xyz, 1.0));
    }
  </script>

  <script id="floor-grid-shader-fs" type="x-shader/x-fragment">
    precision highp float;

    uniform float timeStep;

    varying vec3 pass_aPosition;

    void main(void) {

      if (abs(mod(pass_aPosition.x, 3.0) - 0.5) < 0.15 ||
          abs(mod(pass_aPosition.y, 3.0) - 0.5) < 0.15)
        gl_FragColor = vec4(0.0, 0.25*sin(pass_aPosition.x/100.0)*sin(pass_aPosition.y/100.0), 0.0, 0.5);
      else
        discard;
    }
  </script>
  <script id="floor-grid-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec3 aPosition;

    uniform mat4 uViewMVMatrix;
    uniform mat4 uViewProjMatrix;    

    varying vec3 pass_aPosition;

    void main(void) {
      pass_aPosition = aPosition;
      vec4 pos = uViewProjMatrix * uViewMVMatrix * vec4(aPosition.xyz, 1.0);
      gl_Position = pos;
    }
  </script>
  
  <script type="text/javascript">
    var gl; // gl instance

    // Camera matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        alert("Could not initialize WebGL");
      }

      setupGeometries();
      setupShaderPrograms();
      setupGeoCastFiles();
      setupTextures();
      setupInput(canvas);      

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      
      paintLoop();
    }

    function degToRad(degrees) {
      return degrees * Math.PI / 180;
    }
    function radToDeg(radians) {
      return radians / Math.PI * 180;
    }

    function generateLattice() {
      var vertices = new Float32Array(((2 * (256 + 1 /* Last two for degenerate vertices*/)) * 256) * 3);
      var normalize = function(value) { // Normalize a value between [0;256] to the range [0;1]
        return value / 255;
      }
      for (var y = 0; y < 256 - 1; ++y) {
        // 1 -- 2
        // |  / |
        // | /  |
        // 5 -- 6

        var base_off = (y * (2 * (256 + 1))) * 3;

        // Insert 1 and 5
        vertices[ base_off + 0 ] = normalize(0);
        vertices[ base_off + 1 ] = normalize(y);
        vertices[ base_off + 2 ] = 0;

        vertices[ base_off + 3 ] = normalize(0);
        vertices[ base_off + 4 ] = -normalize(y + 1);
        vertices[ base_off + 5 ] = 0;

        for (var x = 0; x < 256 - 1; ++x) {

           // Insert 2 and 6
           vertices[ base_off + (x * 2 * 3) + 0 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 1 ] = normalize(y);
           vertices[ base_off + (x * 2 * 3) + 2 ] = 0;

           vertices[ base_off + (x * 2 * 3) + 3 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 4 ] = normalize(y + 1);
           vertices[ base_off + (x * 2 * 3) + 5 ] = 0;
        }

        // Insert two extra points to form degenerate triangles (end of row)
        vertices[ base_off + (256 * 2 * 3) + 0 ] = vertices[ base_off + (256 * 2 * 3) + 0 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 1 ] = vertices[ base_off + (256 * 2 * 3) + 1 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 2 ] = vertices[ base_off + (256 * 2 * 3) + 2 - 3 ];

        vertices[ base_off + (256 * 2 * 3) + 3 ] = normalize(0);
        vertices[ base_off + (256 * 2 * 3) + 4 ] = normalize(y + 2);
        vertices[ base_off + (256 * 2 * 3) + 5 ] = 0;
      }
      return vertices;
    }

    var lattice_data;
    var floor_grid_quad_data;
    var cameraFrustumLines;

    function setupGeometries() {
      // Set up a VBO with the field quad data        
      lattice_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      // Generate a 256 x 256 lattice made of triangles with object coords [0;1] for both X and Y
      var vbo_data = generateLattice();
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      lattice_data.n_of_vertices = vbo_data.length / 3; // Number of vertices to use
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      // Set up a VBO with the floor quad data
      floor_grid_quad_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, floor_grid_quad_data);
      vbo_data = [
        -100.0, -100.0,0, 
        -100.0, 100.0,0,
        100.0, 100.0,0,
        100.0, -100.0, 0
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      floor_grid_quad_data.indices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floor_grid_quad_data.indices);
      var indices = [
        0, 1, 2,
        0, 2, 3
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      floor_grid_quad_data.indices_length = indices.length;
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      cameraFrustumLines = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cameraFrustumLines);
      vbo_data = [
        1.0, 1.0, -1.0,
        1.0, 1.0, 1.0,
        -1.0, 1.0, 1.0,
        1.0, -1.0, 1.0,
        -1.0, -1.0, 1.0
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      cameraFrustumLines.indices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cameraFrustumLines.indices);
      indices = [
        0, 1,
        0, 2,
        0, 3,
        0, 4,
        1, 2,
        2, 4,
        4, 3,
        3, 1
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      cameraFrustumLines.indices_length = indices.length;
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    var viewLatticeProgram;
    var drawGridProgram;
    var cameraFrustumLinesProgram;

    // Utility function to get and compile a shader
    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) { // Check for TEXT_NODE
            str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "view-lattice-shader-vs");
      var fragmentShader = getShader(gl, "view-lattice-shader-fs");
      viewLatticeProgram = gl.createProgram();
      gl.attachShader(viewLatticeProgram, vertexShader);
      gl.attachShader(viewLatticeProgram, fragmentShader);
      gl.linkProgram(viewLatticeProgram);
      if (!gl.getProgramParameter(viewLatticeProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(viewLatticeProgram);
      // Bind uniforms and attributes      
      viewLatticeProgram.uViewMVMatrix = gl.getUniformLocation(viewLatticeProgram, "uViewMVMatrix");
      viewLatticeProgram.uViewProjMatrix = gl.getUniformLocation(viewLatticeProgram, "uViewProjMatrix");
      viewLatticeProgram.uGeoCastMVMatrix = gl.getUniformLocation(viewLatticeProgram, "uGeoCastMVMatrix");
      viewLatticeProgram.uGeoCastProjMatrix = gl.getUniformLocation(viewLatticeProgram, "uGeoCastProjMatrix");
      viewLatticeProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(viewLatticeProgram, "uGeoCastMVMatrix_Inverse");
      viewLatticeProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(viewLatticeProgram, "uGeoCastProjMatrix_Inverse");
      viewLatticeProgram.uGeoCastClipRange = gl.getUniformLocation(viewLatticeProgram, "uGeoCastClipRange");
      viewLatticeProgram.aPosition = gl.getAttribLocation(viewLatticeProgram, "aPosition");      
      gl.enableVertexAttribArray(viewLatticeProgram.aPosition);
      viewLatticeProgram.texDepthMapSampler = gl.getUniformLocation(viewLatticeProgram, "texDepthMapSampler");
      viewLatticeProgram.texColorMapSampler = gl.getUniformLocation(viewLatticeProgram, "texColorMapSampler");

      vertexShader = getShader(gl, "floor-grid-shader-vs");
      fragmentShader = getShader(gl, "floor-grid-shader-fs");
      drawGridProgram = gl.createProgram();
      gl.attachShader(drawGridProgram, vertexShader);
      gl.attachShader(drawGridProgram, fragmentShader);
      gl.linkProgram(drawGridProgram);
      if (!gl.getProgramParameter(drawGridProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(drawGridProgram);
      // Bind uniforms and attributes      
      drawGridProgram.uViewMVMatrix = gl.getUniformLocation(drawGridProgram, "uViewMVMatrix");
      drawGridProgram.uViewProjMatrix = gl.getUniformLocation(drawGridProgram, "uViewProjMatrix");
      drawGridProgram.timeStep = gl.getUniformLocation(drawGridProgram, "timeStep");
      drawGridProgram.aPosition = gl.getAttribLocation(drawGridProgram, "aPosition");      
      gl.enableVertexAttribArray(drawGridProgram.aPosition);
      
      vertexShader = getShader(gl, "camera-frustum-lines-shader-vs");
      fragmentShader = getShader(gl, "camera-frustum-lines-shader-fs");
      cameraFrustumLinesProgram = gl.createProgram();
      gl.attachShader(cameraFrustumLinesProgram, vertexShader);
      gl.attachShader(cameraFrustumLinesProgram, fragmentShader);
      gl.linkProgram(cameraFrustumLinesProgram);
      if (!gl.getProgramParameter(cameraFrustumLinesProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(cameraFrustumLinesProgram);
      // Bind uniforms and attributes      
      cameraFrustumLinesProgram.uViewMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewMVMatrix");
      cameraFrustumLinesProgram.uViewProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix");
      cameraFrustumLinesProgram.uGeoCastProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix_Inverse");
      cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix_Inverse");
      cameraFrustumLinesProgram.aPosition = gl.getAttribLocation(drawGridProgram, "aPosition");      
      gl.enableVertexAttribArray(cameraFrustumLinesProgram.aPosition);
    }

    var sceneFrames = 100; // 100 frames
    var geocastObjects = [];
    var selectedFrame = 0;

    function formatNumberWithLeadingZeros(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length - size);
    }

    function setupGeoCastFiles() {
      var callback = function(output) {
        geocastObjects.push(output);
      };      
      for (var i = 1; i <= sceneFrames; ++i) {
        readGeoCastFile("assets/TiltCamera/geocast/" + formatNumberWithLeadingZeros(i, 4) + ".geocast", callback);
      }
    }

    var depthMapTextures = [];
    var colorMapTextures = [];
    var numberOfSafeToRenderTextures = 0;

    function setupTextures() {

      var loadTextureFromFile = function(pngPath, isStartingImage) {
        var texture = gl.createTexture();
        texture.image = new Image();
        texture.image.onload = function () {
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.bindTexture(gl.TEXTURE_2D, null);
          if (texture.isStartingImage == true)
            ++numberOfSafeToRenderTextures;
        }
        texture.image.src = pngPath;
        texture.isStartingImage = isStartingImage;
        return texture;
      };

      for (var i = 1; i <= sceneFrames; ++i) {
        var imageNumber = formatNumberWithLeadingZeros(i, 4);
        var depthMap = loadTextureFromFile("assets/TiltCamera/depth/" + imageNumber + ".png", i == 1);
        depthMapTextures.push(depthMap);
        var colorMap = loadTextureFromFile("assets/TiltCamera/color/" + imageNumber + ".png", i == 1);
        colorMapTextures.push(colorMap);
      }
    }

    var projectionCenter = vec3.fromValues(0, 0, 0); // The center of the projection where the camera points at all times
    var theta = 0.0; // Degrees spherical coord
    var phi = 30.0;   // Degrees spherical coord
    var sphere_d = 50.0; // Start spherical distance

    var mouseDown = false;
    var mouseDownElementId;
    var lastMouseX = null;
    var lastMouseY = null;

    function setupInput(canvas) {
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it
      canvas.onwheel = handleMouseWheel;
      document.onkeydown = handleKeyDown;
    }

    function handleKeyDown(event) {
      var key = event.keyCode || event.which;
      switch (key) {
        case 39: { // Right keyboard arrow
          selectedFrame = Math.min(sceneFrames - 1, selectedFrame + 1);
        } break;
        case 37: { // Left keyboard arrow
          selectedFrame = Math.max(0, selectedFrame - 1);
        } break;
      }
    }

    function onMouseOutOfCanvas(event) {
      var e = event.toElement || event.relatedTarget;
      if (mouseDownElementId !== "canvas") // This is not handled for arrows
        return;
      handleMouseUp(event);
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.clientX;
      var newY = event.clientY;
      var deltaX = newX - lastMouseX;
      var deltaY = newY - lastMouseY;

      if (mouseDownElementId == "canvas") { // Canvas handling

        var d_theta = deltaX / 10.0;
        var d_phi   = deltaY / 10.0;

        theta += d_theta;
        if (theta >= 360.0) // Constrain theta in the [0;360] range
          theta = theta % 360.0;
        if (theta < 0.0)
          theta += 360.0; 
       
        phi += d_phi;
        if (phi > 90.0) phi = 90.0;   // Constrain phi in the [-90;90] range
        if (phi < -90.0) phi = -90.0; // to avoid up vector problems
     
      }

      lastMouseX = newX;
      lastMouseY = newY;
    }

    function handleMouseWheel(event) {
      // Get cross-browser wheel delta
      var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.deltaY || -event.detail)));
      //var delta = Math.max(-1, Math.min(1, event.wheelDelta));
 
      sphere_d += delta;
    }

    var timeStep = 0.0;

    function drawScene() {

      if(numberOfSafeToRenderTextures < 2) // Both a color and depth starting image need to be loaded
        return;

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

      // -------------- Render floor grid -------------

      mat4.identity(modelViewMatrix);
      mat4.identity(perspectiveMatrix);

      // Calculate camera position (eye field) according to the spherical coords
      var cameraPos = vec3.create();
      cameraPos[0] = sphere_d * Math.sin(degToRad(theta)) * Math.cos(degToRad(phi));  
      cameraPos[1] = sphere_d * Math.cos(degToRad(theta)) * Math.cos(degToRad(phi));
      cameraPos[2] = sphere_d * Math.sin(degToRad(phi));  

      gui_prompt.innerHTML = 'TimeStep' + timeStep + ' Phi:' + phi + 'deg Theta:' + theta + 'deg sphere_d:' + sphere_d ;

      mat4.lookAt(modelViewMatrix, /* eye */ cameraPos, /* center */ projectionCenter, /* up */ [0, 0, 1]);
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 500.0);
      gl.useProgram(drawGridProgram);
      gl.uniformMatrix4fv(drawGridProgram.uViewMVMatrix, false /* WebGL supports column-major only */, modelViewMatrix);
      gl.uniformMatrix4fv(drawGridProgram.uViewProjMatrix, false /* WebGL supports column-major only */, perspectiveMatrix);
      gl.uniform1f(drawGridProgram.timeStep, timeStep++);
      gl.bindBuffer(gl.ARRAY_BUFFER, floor_grid_quad_data);
      gl.vertexAttribPointer(drawGridProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floor_grid_quad_data.indices);
      gl.drawElements(gl.TRIANGLES, floor_grid_quad_data.indices_length, gl.UNSIGNED_SHORT, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);      


      // ----------- Render model projection -----------

      // Update and set uniforms for the view
      gl.useProgram(viewLatticeProgram);

      // Update and set uniforms for the GeoCast scene
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastMVMatrix, false /* WebGL supports column-major only */, 
        geocastObjects[selectedFrame].modelviewMatrix);
      // Get a perspective matrix from the geocast structure
      var persp = mat4.create();
      mat4.perspective(persp, degToRad(geocastObjects[selectedFrame].Fovy), geocastObjects[selectedFrame].Aspect, 
                       geocastObjects[selectedFrame].ClipRange[0], geocastObjects[selectedFrame].ClipRange[1]);
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastProjMatrix, false /* WebGL supports column-major only */, 
        persp);
      // Set inverse matrices computed on the CPU
      var inverseMV = mat4.create();
      var inversePr = mat4.create();      
      mat4.invert(inverseMV, geocastObjects[selectedFrame].modelviewMatrix);
      mat4.invert(inversePr, persp);
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastMVMatrix_Inverse, false /* WebGL supports column-major only */, 
        inverseMV);      
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastProjMatrix_Inverse, false /* WebGL supports column-major only */, 
        inversePr);


      // Coordinates from GeoCarve need to be translated to 0;0;0 (they have a different origin)
      //mat4.multiply(modelViewMatrix, modelViewMatrix, inverseMV);


      gl.uniformMatrix4fv(viewLatticeProgram.uViewMVMatrix, false /* WebGL supports column-major only */, 
        modelViewMatrix);
      gl.uniformMatrix4fv(viewLatticeProgram.uViewProjMatrix, false /* WebGL supports column-major only */, 
        perspectiveMatrix);


      gl.uniform2fv(viewLatticeProgram.uGeoCastClipRange, geocastObjects[selectedFrame].ClipRange);

      // Update and set texture samplers
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, depthMapTextures[selectedFrame]);
      gl.uniform1i(viewLatticeProgram.texDepthMapSampler, 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, colorMapTextures[selectedFrame]);
      gl.uniform1i(viewLatticeProgram.texColorMapSampler, 1);

      // Bind VBO, set the vertex attribute data and render
      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      gl.vertexAttribPointer(viewLatticeProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, lattice_data.n_of_vertices);




      // Draw projectors extents lines
      gl.useProgram(cameraFrustumLinesProgram);
      // Bind VBO, set the vertex attribute data and render
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cameraFrustumLines.indices);
      gl.bindBuffer(gl.ARRAY_BUFFER, cameraFrustumLines);
      gl.vertexAttribPointer(cameraFrustumLinesProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewMVMatrix, false /* WebGL supports column-major only */, 
        modelViewMatrix);      
      gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewProjMatrix, false /* WebGL supports column-major only */, 
        perspectiveMatrix);
      gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix, false /* WebGL supports column-major only */, 
        geocastObjects[selectedFrame].modelviewMatrix);
      gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix, false /* WebGL supports column-major only */, 
        persp);
      gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse, false /* WebGL supports column-major only */, 
        inverseMV);      
      gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse, false /* WebGL supports column-major only */, 
        inversePr);
      gl.drawElements(gl.LINES, cameraFrustumLines.indices_length, gl.UNSIGNED_SHORT, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    
    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }

  </script>
</head>
<body onload="webGLStart();">
  <canvas id="canvas" style="border: none;" width="1200" height="800"></canvas>
    <div id="gui_prompt"></div>

</body>
</html>