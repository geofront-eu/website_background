<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Background demo</title>
  <script type="text/javascript" src="utils/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>

  <script id="view-lattice-shader-fs" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D texDepthMapSampler;

    varying vec3 pass_Pos;

    void main(void) {
      vec4 color = texture2D(texDepthMapSampler, pass_Pos.xy);
      gl_FragColor = color;
    }
  </script>
  <script id="view-lattice-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec3 aPosition;

    uniform mat4 uMVMatrix;
    uniform mat4 uProjMatrix;
    uniform sampler2D texDepthMapSampler;

    varying vec3 pass_Pos;

    void main(void) {
      pass_Pos = aPosition;
      vec4 color = texture2D(texDepthMapSampler, pass_Pos.xy);
      pass_Pos.z = 1.0 - ((color.r + color.g + color.b) / 3.0);
      gl_Position = uProjMatrix * uMVMatrix * vec4(pass_Pos, 1.0);
    }
  </script>
  
  <script type="text/javascript">
    var gl; // gl instance
    var fptex_extension;
    var fptextlinear_extension;

    // Camera matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        alert("Could not initialize WebGL");
      }

      fptex_extension = gl.getExtension('OES_texture_float'); // Enable floating point textures
      if (fptex_extension == null) {
        alert("Floating point textures extension not supported");
        return;
      }
      fptextlinear_extension = gl.getExtension('OES_texture_float_linear'); // Enable floating point textures linear filtering
      if (fptextlinear_extension == null) {
        alert("Floating point textures linear filtering extension not supported");
        return;
      }

      setupGeometries();
      setupShaderPrograms();
      setupTextures();
      setupInput(canvas);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      
      paintLoop();
    }

    function degToRad(degrees) {
      return degrees * Math.PI / 180;
    }

    function generateLattice() {
      var vertices = new Float32Array(((2 * (256 + 1 /* Last two for degenerate vertices*/)) * 256) * 3);
      var normalize = function(value) { // Normalize a value between [0;256] to the range [0;1]
        return value / 255;
      }
      for (var y = 0; y < 256 - 1; ++y) {
        // 1 -- 2
        // |  / |
        // | /  |
        // 5 -- 6

        var base_off = (y * (2 * (256 + 1))) * 3;

        // Insert 1 and 5
        vertices[ base_off + 0 ] = normalize(0);
        vertices[ base_off + 1 ] = normalize(y);
        vertices[ base_off + 2 ] = 0;

        vertices[ base_off + 3 ] = normalize(0);
        vertices[ base_off + 4 ] = -normalize(y + 1);
        vertices[ base_off + 5 ] = 0;

        for (var x = 0; x < 256 - 1; ++x) {

           // Insert 2 and 6
           vertices[ base_off + (x * 2 * 3) + 0 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 1 ] = normalize(y);
           vertices[ base_off + (x * 2 * 3) + 2 ] = 0;

           vertices[ base_off + (x * 2 * 3) + 3 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 4 ] = normalize(y + 1);
           vertices[ base_off + (x * 2 * 3) + 5 ] = 0;
        }

        // Insert two extra points to form degenerate triangles (end of row)
        vertices[ base_off + (256 * 2 * 3) + 0 ] = vertices[ base_off + (256 * 2 * 3) + 0 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 1 ] = vertices[ base_off + (256 * 2 * 3) + 1 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 2 ] = vertices[ base_off + (256 * 2 * 3) + 2 - 3 ];

        vertices[ base_off + (256 * 2 * 3) + 3 ] = normalize(0);
        vertices[ base_off + (256 * 2 * 3) + 4 ] = normalize(y + 2);
        vertices[ base_off + (256 * 2 * 3) + 5 ] = 0;
      }
      return vertices;
    }

    var lattice_data;

    function setupGeometries() {
      // Set up a VBO with the field quad data        
      lattice_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      // Generate a 256 x 256 lattice made of triangles
      var vbo_data = generateLattice();
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      lattice_data.n_of_vertices = vbo_data.length / 3; // Number of vertices to use
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    var viewLatticeProgram;

    // Utility function to get and compile a shader
    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) { // Check for TEXT_NODE
            str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "view-lattice-shader-vs");
      var fragmentShader = getShader(gl, "view-lattice-shader-fs");
      viewLatticeProgram = gl.createProgram();
      gl.attachShader(viewLatticeProgram, vertexShader);
      gl.attachShader(viewLatticeProgram, fragmentShader);
      gl.linkProgram(viewLatticeProgram);
      if (!gl.getProgramParameter(viewLatticeProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(viewLatticeProgram);
      // Bind uniforms and attributes      
      viewLatticeProgram.uProjMatrix = gl.getUniformLocation(viewLatticeProgram, "uProjMatrix");
      viewLatticeProgram.uMVMatrix = gl.getUniformLocation(viewLatticeProgram, "uMVMatrix");
      viewLatticeProgram.aPosition = gl.getAttribLocation(viewLatticeProgram, "aPosition");      
      gl.enableVertexAttribArray(viewLatticeProgram.aPosition);
      viewLatticeProgram.texFieldSampler = gl.getUniformLocation(viewLatticeProgram, "texDepthMapSampler");
    }

    var depthMapTexture;
    var fieldTextureIsSafeToRender = false;

    function setupTextures() {
      depthMapTexture = gl.createTexture();
      depthMapTexture.image = new Image();
      depthMapTexture.image.onload = function () {
        gl.bindTexture(gl.TEXTURE_2D, depthMapTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, depthMapTexture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
        fieldTextureIsSafeToRender = true;
      }
      depthMapTexture.image.src = "assets/depthmap.png";
    }

    var sceneRotationMatrix = mat4.create();
    var mouseDown = false;
    var mouseDownElementId;
    var lastMouseX = null;
    var lastMouseY = null;

    function setupInput(canvas) {
      mat4.identity(sceneRotationMatrix);
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it
    }

    function onMouseOutOfCanvas(event) {
      var e = event.toElement || event.relatedTarget;
      if (mouseDownElementId !== "canvas") // This is not handled for arrows
        return;
      handleMouseUp(event);
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.clientX;
      var newY = event.clientY;
      var deltaX = newX - lastMouseX;
      var deltaY = - (newY - lastMouseY);

      if (mouseDownElementId == "canvas") { // Canvas handling        
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
        mat4.multiply(sceneRotationMatrix, newRotationMatrix, sceneRotationMatrix);
      }

      lastMouseX = newX
      lastMouseY = newY;
    }

    function drawScene() {

      if(fieldTextureIsSafeToRender == false)
        return;

      mat4.lookAt(modelViewMatrix, /* eye */ [2, 0.5, 0.2], /* center */ [0.5, 0.5, 0], /* up */ [0, 1, 0]);
      mat4.multiply(modelViewMatrix, modelViewMatrix, sceneRotationMatrix);
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 50.0);      
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);      
      gl.useProgram(viewLatticeProgram);

      gl.uniformMatrix4fv(viewLatticeProgram.uMVMatrix, false /* WebGL supports column-major only */, 
        modelViewMatrix);
      gl.uniformMatrix4fv(viewLatticeProgram.uProjMatrix, false /* WebGL supports column-major only */, 
        perspectiveMatrix);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, depthMapTexture);
      gl.uniform1i(viewLatticeProgram.texFieldSampler, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      gl.vertexAttribPointer(viewLatticeProgram.aPosition, 3, gl.FLOAT, false, 0, 0);      
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, lattice_data.n_of_vertices);      
    }
    
    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }

  </script>
</head>
<body onload="webGLStart();">
  <canvas id="canvas" style="border: none;" width="1200" height="800"></canvas>
</body>
</html>
