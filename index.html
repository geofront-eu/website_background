<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Background demo</title>
  <script type="text/javascript" src="utils/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>
  <script type="text/javascript" src="utils/geocast-filereader.js"></script>

  <script id="view-lattice-shader-fs" type="x-shader/x-fragment">
    precision highp float;

    varying vec4 pass_aPosition;
    varying vec4 pass_color;
    varying vec4 pass_discardFlag;

    void main(void) {
      if(pass_discardFlag.a < 0.999)
        discard;
      gl_FragColor = pass_color;
    }
  </script>
  <script id="view-lattice-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec3 aPosition;

    uniform mat4 uViewMVMatrix;
    uniform mat4 uViewProjMatrix;

    uniform mat4 uGeoCastMVMatrix;
    uniform mat4 uGeoCastProjMatrix;
    uniform mat4 uGeoCastMVMatrix_Inverse;
    uniform mat4 uGeoCastProjMatrix_Inverse;
    uniform vec2 uGeoCastClipRange;

    uniform sampler2D texDepthMapSampler;
    uniform sampler2D texColorMapSampler;

    varying vec4 pass_aPosition;
    varying vec4 pass_color;
    varying vec4 pass_discardFlag;

    void main(void) {
      pass_aPosition = vec4(aPosition.rgb, 1.0);

      vec4 depth = texture2D(texDepthMapSampler, aPosition.xy);
      pass_color = texture2D(texColorMapSampler, aPosition.xy);

      vec4 depth_camspace;  // purpose: "image" a pixel of depth Z (its view vector) into camera space
      depth_camspace = uGeoCastProjMatrix * vec4(0.0, 0.0, mix(-uGeoCastClipRange.x, -uGeoCastClipRange.y, depth.x), 1.0);

      float model_depth = depth_camspace.z / depth_camspace.w;
      // Discard background depths
      pass_discardFlag = vec4(1.0,1.0,1.0, (model_depth < 0.999) ? 1.0 : 0.0);

      vec4 worldpos = uGeoCastMVMatrix_Inverse * uGeoCastProjMatrix_Inverse * vec4(aPosition.x, aPosition.y,  model_depth, 1);
      gl_Position = uViewProjMatrix * uViewMVMatrix * worldpos;
    }
  </script>
  
  <script type="text/javascript">
    var gl; // gl instance
    var fptex_extension;
    var fptextlinear_extension;

    // Camera matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        alert("Could not initialize WebGL");
      }

      fptex_extension = gl.getExtension('OES_texture_float'); // Enable floating point textures
      if (fptex_extension == null) {
        alert("Floating point textures extension not supported");
        return;
      }
      fptextlinear_extension = gl.getExtension('OES_texture_float_linear'); // Enable floating point textures linear filtering
      if (fptextlinear_extension == null) {
        alert("Floating point textures linear filtering extension not supported");
        return;
      }

      setupGeometries();
      setupShaderPrograms();
      setupGeoCastFiles();
      setupTextures();
      setupInput(canvas);      

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      
      paintLoop();
    }

    function degToRad(degrees) {
      return degrees * Math.PI / 180;
    }

    function generateLattice() {
      var vertices = new Float32Array(((2 * (256 + 1 /* Last two for degenerate vertices*/)) * 256) * 3);
      var normalize = function(value) { // Normalize a value between [0;256] to the range [0;1]
        return value / 255;
      }
      for (var y = 0; y < 256 - 1; ++y) {
        // 1 -- 2
        // |  / |
        // | /  |
        // 5 -- 6

        var base_off = (y * (2 * (256 + 1))) * 3;

        // Insert 1 and 5
        vertices[ base_off + 0 ] = normalize(0);
        vertices[ base_off + 1 ] = normalize(y);
        vertices[ base_off + 2 ] = 0;

        vertices[ base_off + 3 ] = normalize(0);
        vertices[ base_off + 4 ] = -normalize(y + 1);
        vertices[ base_off + 5 ] = 0;

        for (var x = 0; x < 256 - 1; ++x) {

           // Insert 2 and 6
           vertices[ base_off + (x * 2 * 3) + 0 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 1 ] = normalize(y);
           vertices[ base_off + (x * 2 * 3) + 2 ] = 0;

           vertices[ base_off + (x * 2 * 3) + 3 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 4 ] = normalize(y + 1);
           vertices[ base_off + (x * 2 * 3) + 5 ] = 0;
        }

        // Insert two extra points to form degenerate triangles (end of row)
        vertices[ base_off + (256 * 2 * 3) + 0 ] = vertices[ base_off + (256 * 2 * 3) + 0 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 1 ] = vertices[ base_off + (256 * 2 * 3) + 1 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 2 ] = vertices[ base_off + (256 * 2 * 3) + 2 - 3 ];

        vertices[ base_off + (256 * 2 * 3) + 3 ] = normalize(0);
        vertices[ base_off + (256 * 2 * 3) + 4 ] = normalize(y + 2);
        vertices[ base_off + (256 * 2 * 3) + 5 ] = 0;
      }
      return vertices;
    }

    var lattice_data;

    function setupGeometries() {
      // Set up a VBO with the field quad data        
      lattice_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      // Generate a 256 x 256 lattice made of triangles
      var vbo_data = generateLattice();
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      lattice_data.n_of_vertices = vbo_data.length / 3; // Number of vertices to use
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    var viewLatticeProgram;

    // Utility function to get and compile a shader
    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) { // Check for TEXT_NODE
            str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "view-lattice-shader-vs");
      var fragmentShader = getShader(gl, "view-lattice-shader-fs");
      viewLatticeProgram = gl.createProgram();
      gl.attachShader(viewLatticeProgram, vertexShader);
      gl.attachShader(viewLatticeProgram, fragmentShader);
      gl.linkProgram(viewLatticeProgram);
      if (!gl.getProgramParameter(viewLatticeProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(viewLatticeProgram);
      // Bind uniforms and attributes      
      viewLatticeProgram.uViewMVMatrix = gl.getUniformLocation(viewLatticeProgram, "uViewMVMatrix");
      viewLatticeProgram.uViewProjMatrix = gl.getUniformLocation(viewLatticeProgram, "uViewProjMatrix");
      viewLatticeProgram.uGeoCastMVMatrix = gl.getUniformLocation(viewLatticeProgram, "uGeoCastMVMatrix");
      viewLatticeProgram.uGeoCastProjMatrix = gl.getUniformLocation(viewLatticeProgram, "uGeoCastProjMatrix");
      viewLatticeProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(viewLatticeProgram, "uGeoCastMVMatrix_Inverse");
      viewLatticeProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(viewLatticeProgram, "uGeoCastProjMatrix_Inverse");
      viewLatticeProgram.uGeoCastClipRange = gl.getUniformLocation(viewLatticeProgram, "uGeoCastClipRange");
      viewLatticeProgram.aPosition = gl.getAttribLocation(viewLatticeProgram, "aPosition");      
      gl.enableVertexAttribArray(viewLatticeProgram.aPosition);
      viewLatticeProgram.texDepthMapSampler = gl.getUniformLocation(viewLatticeProgram, "texDepthMapSampler");
      viewLatticeProgram.texColorMapSampler = gl.getUniformLocation(viewLatticeProgram, "texColorMapSampler");
    }

    var sceneFrames = 100; // 100 frames
    var geocastObjects = [];

    function formatNumberWithLeadingZeros(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length - size);
    }

    function setupGeoCastFiles() {
      var callback = function(output) {
        geocastObjects.push(output);
      };      
      for (var i = 1; i <= sceneFrames; ++i) {
        readGeoCastFile("assets/TiltCamera/geocast/" + formatNumberWithLeadingZeros(i, 4) + ".geocast", callback);
      }
    }

    var depthMapTextures = [];
    var colorMapTextures = [];
    var numberOfSafeToRenderTextures = 0;

    function setupTextures() {

      var loadTextureFromFile = function(pngPath) {
        var texture = gl.createTexture();
        texture.image = new Image();
        texture.image.onload = function () {
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.bindTexture(gl.TEXTURE_2D, null);
          ++numberOfSafeToRenderTextures;
        }
        texture.image.src = pngPath;
        return texture;
      };

      for (var i = 1; i <= sceneFrames; ++i) {
        var imageNumber = formatNumberWithLeadingZeros(i, 4);
        var depthMap = loadTextureFromFile("assets/TiltCamera/depth/" + imageNumber + ".png");
        depthMapTextures.push(depthMap);
        var colorMap = loadTextureFromFile("assets/TiltCamera/color/" + imageNumber + ".png");
        colorMapTextures.push(colorMap);
      }
    }

    var sceneRotationMatrix = mat4.create();
    var mouseDown = false;
    var mouseDownElementId;
    var lastMouseX = null;
    var lastMouseY = null;

    function setupInput(canvas) {
      mat4.identity(sceneRotationMatrix);
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it
    }

    function onMouseOutOfCanvas(event) {
      var e = event.toElement || event.relatedTarget;
      if (mouseDownElementId !== "canvas") // This is not handled for arrows
        return;
      handleMouseUp(event);
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.clientX;
      var newY = event.clientY;
      var deltaX = newX - lastMouseX;
      var deltaY = - (newY - lastMouseY);

      if (mouseDownElementId == "canvas") { // Canvas handling        
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
        mat4.rotate(newRotationMatrix, newRotationMatrix, degToRad(deltaY / 10), [0, 0, 1]);
        mat4.multiply(sceneRotationMatrix, newRotationMatrix, sceneRotationMatrix);
      }

      lastMouseX = newX
      lastMouseY = newY;
    }

    function drawScene() {

      if(numberOfSafeToRenderTextures == 0)
        return;

      // Update and set uniforms for the view
      var mm = mat4.create();
      mat4.identity(mm);
      mat4.lookAt(modelViewMatrix, /* eye */ [1.5, 1.3, 0.4], /* center */ [0.5, 0.5, 0], /* up */ [0, 1, 0]);
      mat4.multiply(modelViewMatrix, modelViewMatrix, sceneRotationMatrix);
      mat4.translate(modelViewMatrix, modelViewMatrix, [-0.5, -0.5, 0]); // Renders the rotation on the vertical axis of the grid
      
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);      
      gl.useProgram(viewLatticeProgram);

      gl.uniformMatrix4fv(viewLatticeProgram.uViewMVMatrix, false /* WebGL supports column-major only */, 
        modelViewMatrix);
      gl.uniformMatrix4fv(viewLatticeProgram.uViewProjMatrix, false /* WebGL supports column-major only */, 
        perspectiveMatrix);

      // Update and set uniforms for the GeoCast scene
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastMVMatrix, false /* WebGL supports column-major only */, 
        geocastObjects[0].modelviewMatrix);
      // Get a perspective matrix from the geocast structure
      var persp = mat4.create();
      mat4.perspective(persp, degToRad(geocastObjects[0].Fovy), geocastObjects[0].Aspect, geocastObjects[0].ClipRange[0], geocastObjects[0].ClipRange[1]);
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastProjMatrix, false /* WebGL supports column-major only */, 
        persp);
      // Set inverse matrices computed on the CPU
      var inverseMV = mat4.create();
      var inversePr = mat4.create();
      mat4.invert(inverseMV, geocastObjects[0].modelviewMatrix);
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastMVMatrix_Inverse, false /* WebGL supports column-major only */, 
        inverseMV);
      mat4.invert(inversePr, persp);
      gl.uniformMatrix4fv(viewLatticeProgram.uGeoCastProjMatrix_Inverse, false /* WebGL supports column-major only */, 
        inversePr);

      gl.uniform2fv(viewLatticeProgram.uGeoCastClipRange, geocastObjects[0].ClipRange);

      // Update and set texture samplers
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, depthMapTextures[0]);
      gl.uniform1i(viewLatticeProgram.texDepthMapSampler, 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, colorMapTextures[0]);
      gl.uniform1i(viewLatticeProgram.texColorMapSampler, 1);

      // Bind VBO, set the vertex attribute data and render
      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      gl.vertexAttribPointer(viewLatticeProgram.aPosition, 3, gl.FLOAT, false, 0, 0);      
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, lattice_data.n_of_vertices);      
    }
    
    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }

  </script>
</head>
<body onload="webGLStart();">
  <canvas id="canvas" style="border: none;" width="1200" height="800"></canvas>
</body>
</html>