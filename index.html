<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Background demo</title>
  <script type="text/javascript" src="utils/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>

  <script id="view-lattice-shader-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec3 pass_Pos;
    void main(void) {
      gl_FragColor = vec4(pass_Pos, 1.0);
    }
  </script>
  <script id="view-lattice-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec3 aPosition;
    uniform mat4 uMVMatrix;
    uniform mat4 uProjMatrix;
    varying vec3 pass_Pos;
    void main(void) {
      pass_Pos = aPosition;
      gl_Position = uProjMatrix * uMVMatrix * vec4(aPosition, 1.0);
    }
  </script>
  
  <script type="text/javascript">
    var gl; // gl instance

    // Camera matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        alert("Could not initialize WebGL");
      }

      setupGeometries();
      setupShaderPrograms();

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      
      paintLoop();
    }

    function degToRad(degrees) {
      return degrees * Math.PI / 180;
    }

    function generateLattice() {
      var vertices = new Float32Array(((2 * (256 + 1 /* Last two for degenerate vertices*/)) * 256) * 3);
      var normalize = function(value) { // Normalize a value between [0;256] to the range [0;1]
        return value / 255;
      }
      for (var y = 0; y < 256 - 1; ++y) {
        // 1 -- 2
        // |  / |
        // | /  |
        // 5 -- 6

        var base_off = (y * (2 * (256 + 1))) * 3;

        // Insert 1 and 5
        vertices[ base_off + 0 ] = normalize(0);
        vertices[ base_off + 1 ] = normalize(y);
        vertices[ base_off + 2 ] = 0;

        vertices[ base_off + 3 ] = normalize(0);
        vertices[ base_off + 4 ] = -normalize(y + 1);
        vertices[ base_off + 5 ] = 0;

        for (var x = 0; x < 256 - 1; ++x) {

           // Insert 2 and 6
           vertices[ base_off + (x * 2 * 3) + 0 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 1 ] = normalize(y);
           vertices[ base_off + (x * 2 * 3) + 2 ] = 0;

           vertices[ base_off + (x * 2 * 3) + 3 ] = normalize(x + 1);
           vertices[ base_off + (x * 2 * 3) + 4 ] = normalize(y + 1);
           vertices[ base_off + (x * 2 * 3) + 5 ] = 0;
        }

        // Insert two extra points to form degenerate triangles (end of row)
        vertices[ base_off + (256 * 2 * 3) + 0 ] = vertices[ base_off + (256 * 2 * 3) + 0 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 1 ] = vertices[ base_off + (256 * 2 * 3) + 1 - 3 ];
        vertices[ base_off + (256 * 2 * 3) + 2 ] = vertices[ base_off + (256 * 2 * 3) + 2 - 3 ];

        vertices[ base_off + (256 * 2 * 3) + 3 ] = normalize(0);
        vertices[ base_off + (256 * 2 * 3) + 4 ] = normalize(y + 2);
        vertices[ base_off + (256 * 2 * 3) + 5 ] = 0;
      }
      return vertices;
    }

    var lattice_data;

    function setupGeometries() {
      // Set up a VBO with the field quad data        
      lattice_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      // Generate a 256 x 256 lattice made of triangles
      var vbo_data = generateLattice();
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      lattice_data.n_of_vertices = vbo_data.length / 3; // Number of vertices to use
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    var viewLatticeProgram;

    // Utility function to get and compile a shader
    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) { // Check for TEXT_NODE
            str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "view-lattice-shader-vs");
      var fragmentShader = getShader(gl, "view-lattice-shader-fs");
      viewLatticeProgram = gl.createProgram();
      gl.attachShader(viewLatticeProgram, vertexShader);
      gl.attachShader(viewLatticeProgram, fragmentShader);
      gl.linkProgram(viewLatticeProgram);
      if (!gl.getProgramParameter(viewLatticeProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(viewLatticeProgram);
      // Bind uniforms and attributes      
      viewLatticeProgram.uProjMatrix = gl.getUniformLocation(viewLatticeProgram, "uProjMatrix");
      viewLatticeProgram.uMVMatrix = gl.getUniformLocation(viewLatticeProgram, "uMVMatrix");
      viewLatticeProgram.aPosition = gl.getAttribLocation(viewLatticeProgram, "aPosition");
      gl.enableVertexAttribArray(viewLatticeProgram.aPosition);
    }

    function drawScene() {
      mat4.lookAt(modelViewMatrix, /* eye */ [0, 0, 5], /* center */ [0, 0, 0], /* up */ [0, 1, 0]); 
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 50.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);      
      gl.useProgram(viewLatticeProgram);

      gl.uniformMatrix4fv(viewLatticeProgram.uMVMatrix, false /* WebGL supports column-major only */, 
        modelViewMatrix);
      gl.uniformMatrix4fv(viewLatticeProgram.uProjMatrix, false /* WebGL supports column-major only */, 
        perspectiveMatrix);

      gl.bindBuffer(gl.ARRAY_BUFFER, lattice_data);
      gl.vertexAttribPointer(viewLatticeProgram.aPosition, 3, gl.FLOAT, false, 0, 0);      
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, lattice_data.n_of_vertices);
    }
    
    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }

  </script>
</head>
<body onload="webGLStart();">
  <canvas id="canvas" style="border: none;" width="1200" height="800"></canvas>
</body>
</html>